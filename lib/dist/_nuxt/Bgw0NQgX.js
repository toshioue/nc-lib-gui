import{u as E}from"./GMLocJHP.js";import{r as M,J as A,ay as L,ax as P,f as x,ah as m,ai as c,y as T}from"./DZZ6t_j4.js";import{e as _}from"./BDAIZopQ.js";const[K,W]=E((o,i)=>{const p=M(!1),{isUIAllowed:y}=A(),{$e:g,$state:f,$api:d}=T(),a=M([]),S=L(),{basesUser:U}=P(S),w=x(()=>o.value.base_id?U.value.get(o.value.base_id)||[]:[]),C=async(s,r=!0)=>{if(!y("commentList")||!i.value&&!s)return;const e=s??_(i.value.row,o.value.columns);if(e)try{r||(p.value=!0);const t=(await d.utils.commentList({row_id:e,fk_model_id:o.value.id})).list||[];a.value=t.map(l=>{const u=w.value.find(v=>v.id===l.created_by),n=l.resolved_by?w.value.find(v=>v.id===l.resolved_by):null;return{...l,created_display_name:(u==null?void 0:u.display_name)??((u==null?void 0:u.email)??"").split("@")[0],resolved_display_name:n?n.display_name??n.email.split("@")[0]:void 0}})}catch(t){m.error(await c(t))}finally{r||(p.value=!1)}},$=async s=>{if(!y("commentDelete"))return;const r=a.value.find(e=>e.id===s);if(r)try{a.value=a.value.filter(e=>e.id!==s),await d.utils.commentDelete(s),Object.assign(i.value,{...i.value,rowMeta:{...i.value.rowMeta,commentCount:(i.value.rowMeta.commentCount??1)-1}})}catch(e){m.error(await c(e)),a.value=[...a.value,r]}},k=async s=>{if(!y("commentResolve"))return;const r=a.value.find(e=>e.id===s);if(r)try{a.value=a.value.map(e=>{var t,l,u,n,v,b,R,h;return e.id===s?{...e,resolved_by:r.resolved_by||(l=(t=f.user)==null?void 0:t.value)==null?void 0:l.id,resolved_by_email:r.resolved_by||(n=(u=f.user)==null?void 0:u.value)==null?void 0:n.email,resolved_display_name:r.resolved_by?void 0:((b=(v=f.user)==null?void 0:v.value)==null?void 0:b.display_name)??((h=(R=f.user)==null?void 0:R.value)==null?void 0:h.email.split("@")[0])}:e}),await d.utils.commentResolve(s,{})}catch(e){a.value=a.value.map(t=>t.id===s?r:t),m.error(await c(e))}},O=async s=>{var r;try{if(!i.value||!s){a.value=a.value.filter(t=>{var l;return!((l=t.id)!=null&&l.startsWith("temp-"))});return}const e=_(i.value.row,o.value.columns);if(!e)return;await d.utils.commentRow({fk_model_id:(r=o.value)==null?void 0:r.id,row_id:e,comment:`${s}`.replace(/(<br \/>)+$/g,"")}),Object.assign(i.value,{rowMeta:{...i.value.rowMeta,commentCount:(i.value.rowMeta.commentCount??0)+1}}),await C()}catch(e){a.value=a.value.filter(t=>!(t.id??"").startsWith("temp-")),m.error(await c(e))}g("a:row-expand:comment")},j=async(s,r)=>{const e=a.value.find(t=>t.id===s);if(e)try{a.value=a.value.map(t=>t.id===s?{...t,...r,updated_at:new Date().toISOString()}:t),await d.utils.commentUpdate(s,r)}catch(t){a.value=a.value.map(l=>l.id===s?e:l),m.error(await c(t))}},D=x(()=>_(i.value.row,o.value.columns));return{comments:a,loadComments:C,saveComment:O,updateComment:j,resolveComment:k,deleteComment:$,isCommentsLoading:p,primaryKey:D}});function N(){const o=W();if(!o)throw new Error("useRowComments is not provided");return o}export{K as a,N as u};
